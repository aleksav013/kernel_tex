\documentclass[a4paper,fleqn,12pt]{JMThesis}
\renewcommand{\footnotesize}{\fontsize{9pt}{11pt}\selectfont}
\usepackage{listings}
\lstset{
    basicstyle=\footnotesize,
    frame=single,
    showstringspaces=false,
    tabsize=4,
    escapeinside={<@}{@>},
%    numbers=left
}
\lstset{defaultdialect=[x86masm]Assembler}

\usepackage[OT2]{fontenc}
\newcommand\eng{\fontencoding{OT1}\fontfamily{\rmdefault}\selectfont}
\newcommand\srb{\fontencoding{OT2}\fontfamily{\rmdefault}\selectfont}

% \usepackage[serbian,english]{babel}

\renewcommand{\baselinestretch}{1}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{tocloft}
\usepackage[
    backend=bibtex,
    natbib=true,
    style=numeric,
    block=ragged,
    sorting=none
]{biblatex}
\bibliography{kernel}
\renewcommand*{\bibfont}{\eng}

\newlength\tindent
\setlength{\tindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}
\renewcommand{\indent}{\hspace*{\tindent}}

\oddsidemargin 1cm
\evensidemargin 0cm
\textwidth 15cm

\pagestyle{headings}

\font \matematicka=wncsc10 scaled 1600
\font \maturski=wncyb10 scaled 2500
\font \naslov=wncyb10 scaled 1900
\font \naslovlat=cmr10 scaled 1900
\font \imen=wncyr10 scaled 1600


\def\zn{,\kern-0.09em,}
\def\zng{'\kern-0.09em'}
\pagenumbering{roman}
\begin{document}


\thispagestyle{empty}

\begin{center}
{\matematicka Matematichka gimnazija}
\end{center}
\vspace*{50mm}

\begin{center}
{\maturski MATURSKI RAD}

\vspace*{8pt}
{\naslov - iz rachunarstva i informatike -}
\end{center}

\vspace*{10pt}
\begin{center}
    {\naslov \textbf{\eng\Large 32bit X86} jezgro operativnog sistema}
\end{center}

\vspace*{70mm}
\setlength{\columnsep}{50pt}
\begin{multicols}{2}
 {\noindent \imen Uchenik:
\\Aleksa Vuchkovic1  $\operatorname{IV}$c}


{ \noindent \hfill \imen Mentor:\\
\hfill \phantom{aaaaaaaa} Milosh Arsic1}
\end{multicols}

\vfill
\begin{center}
{\imen Beograd, jun 2022.}
\end{center}
\clearpage

\thispagestyle{empty}
\mbox{}
\clearpage


\renewcommand{\contentsname}{Sadrzhaj}
\thispagestyle{empty}

\pagenumbering{gobble}

\tableofcontents \clearpage

\thispagestyle{empty}
\mbox{}
\clearpage

\pagenumbering{arabic}
\renewcommand{\chaptername}{}
\setcounter{page}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Uvod}
\bigskip

Ideja za ovaj rad proizishla je iz ekstenzivnog korish\/c1enja {\eng GNU/Linux}
sistema, kao i zhelja za razumevanjem rada rachunara na najnizhem nivou.\\

Ceo kod je pisan u {\eng GNU Assembler}-u i {\eng C}-u i mozhe se nac1i na
{\eng GitHub}-u na stranici {\eng\url{https://github.com/aleksav013/mykernel}}.
Kod, zajedno sa svim alatima za njegovo korish\/c1enje i upotrebu, je dostupan
pod {\eng GPLv3} licencom.\\

Ovaj projekat se konstantno unapredjuje i nemoguc1e je odrzhavati
sinhronizovanim fajlove koji sachinjavaju operativni sistem, a koji se
istovremeno pominju u ovom radu. Iz tog razloga, rad c1e biti napisan za
verziju operativnog sistema 1.0.0. Na stranici {\eng GitHub}-a ova verzija se
mozhe nac1i pod {\eng tag/s} sekcijom na stranici projekta.\\

Radi laksheg kompajlovanja koda od strane chitaoca, kreiran je {\eng toolchain}
- set alata, specifichno za kompajlovanje ovog operativnog sistema, koji se
mozhe nac1i na stranici
{\eng\url{https://github.com/aleksav013/aleksa-toolchain}},
takodje dostupan pod {\eng GPLv3} licencom otvorenog koda. Set alata {\eng
aleksa-toolchain} kreiran je takodje i iz razloga shto je zapravo neizbezhan
proces kreiranja \text{{\eng cross-compiler}-a} - kompajlera koji kompajluje
kod za drugi sistem/arhitekturu na trenutnom sistemu/arhitekturi. Na taj nachin
i drugi ljudi osim autora mogu doprineti izradi i poboljshanju ovog operativnog
sistema u buduc1nosti.\\

Ovaj projekat ima za cilj da prikazhe postupak kreiranja jednog za sada
vrlo jednostavnog operativnog sistema, kao i da potkrepi chitaoce teorijom
potrebnom za njegovo razumevanje.\\

\newpage

\begin{multicols}{2}
Trenutno radi:
\begin{itemize}
\item {\eng Boot}
\item {\eng VGA} izlaz
\item {\eng GDT}
\item {\eng IDT}
\item {\eng IRQ \& PIC}
\item {\eng PS/2} tastatura
\item {\eng PIT}
\item {\eng Heap}
\item {\eng Paging}
\item {\eng C} biblioteka
\end{itemize}

\columnbreak

Planirano u blizhoj buduc1nosti:
\begin{itemize}
\item {\eng Filesystem}
\item {\eng Framebuffer}
\item {\eng Networking}
\item {\eng Real User Space}
\end{itemize}
\end{multicols}

O stvarima koje su implementirane i koje funkcionishu, moc1i c1ete da saznate
vishe u ovom radu. Autorov plan je da predstojec1e slobodno vreme nakon
maturiranja i tokom studija, iskoristi na unapredjenje ovog malog operativnog
sistema, i da u mu ovaj rad kao takav bude osnova za naredni.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{{\eng X86} arhitektura}
\bigskip

{\eng X86} je familija arhitektura {\eng CISC} seta instrukcija razvijena od
strane Intel-a koja je bazirana na 8086 mikroprocesoru. 8086 je nastao 1978.
kao shesnaestobitna ekstenzija 8080 osmobitnog mikroprocesora, da bi 1985.
godine nastao 80386 sa velichinom registra od chak 32 bita. Svi procesori iz
ove familije nose zajednichki naziv upravo po sufiksu 86 koji se pojavljuje u
imenima svih ovih procesora.\\

U periodu od 1999. do 2003. {\eng AMD} je proshirio velichinu registra na 64 bita
i ta arhitektura ima vishe naziva od kojih su najkorish\/c1eniji: {\eng
x86\_64, amd64} i {\eng x64}. Velika vec1ina uredjaja danas koristi {\eng
x86\_64} arhitekturu procesora.\\

Jezgo operativnog sistema prikazano u ovom radu bazirano je na {\eng X86}
arhitekturi sa registrom velichine 32 bita. Konkretna verzija ove arhitekture
je {\eng i386}. Ova verzija dobila je ime po Intelovom mikroprocesoru pod
imenom 80386 shto oznachava trec1u generaciju {\eng X86} arhitekture.


\section{Registri procesora}
\medskip

Postoji vishe vrsta registara procesora\cite[75]{misc:1}. Neki od osnovnih
registara koje je potrebno pomenuti dati su u tekstu koji sledi. Razlog zbog
kojeg su navedena i imena registara prethodnih verzija {\eng X86} arhitekture
je zbog toga shto je moguc1e adresirati prvih {\eng x} bitova, ako se koristi
ime registra za {\eng x}-tobitnu verziju {\eng X86} arhitekture. Naravno, ovo
vazhi samo ukoliko je duzhina registra nasheg sistema (32 bita), vec1a ili
jednaka duzhini registra chiju notaciju koristimo.

\newpage
Registri opshte namene:\\[1mm]
{\eng\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
8bit & al & bl & cl & dl & sil & dil & spl & bpl \\
\hline
16bit & ax & bx & cx & dx & si & di & sp & bp \\
\hline
32bit & eax & ebx & ecx & edx & esi & edi & esp & ebp \\
\hline
64bit & rax & rbx & rcx & rdx & rsi & rdi & rsp & rdp \\
\hline
\end{tabular}}\\

Segmentni registri:\\[1mm]
{\eng\begin{tabular}{|c|c|c|c|c|c|}
\hline
cs & ds & ss & es & fs & gs \\
\hline
\end{tabular}}\\

Kontrolni registri:\\[1mm]
{\eng\begin{tabular}{|c|c|c|c|c|}
\hline
cr0 & cr2 & cr3 & cr4 & cr8 \\
\hline
\end{tabular}}\\

Sistemski registri (pokazivachi na tabele):\\[1mm]
{\eng\begin{tabular}{|c|c|c|}
\hline
gdtr & ldtr & idtr \\
\hline
\end{tabular}}\\

Osim pomenutih, pochev od shesnaestobitne {\eng X86} arhitekture, postoje i
registri {\eng ah, bh, ch, dh (h-higher)} koji predstavljaju gornju polovinu
(od 9. do 16. bita) {\eng ax, bx, cx, dx} registara redom. U daljem tekstu
bic1e prikazan odnos izmedju registara o kome je ranije bilo rechi, kao i
prikaz i na to od kog do kog bita registra se odnosi data notacija.\\

{\eng\begin{tabular}{|c|c|c|c|c|c|c|c|}
63-56 & 55-48 & 47-40 & 39-32 & 31-24 & 23-16 & 15-8 & 7-0 \\
\hline
&&&&&& ah & al \\
\hline
&&&&&& \multicolumn{2}{|c|}{ax} \\
\hline
&&&& \multicolumn{4}{|c|}{eax} \\
\hline
\multicolumn{8}{|c|}{rax} \\
\hline
\end{tabular}}\\

Primetimo da ukoliko nas interesuje vrednost drugog bajta u {\eng X86\_64}
arhitekturi, do nje mozhemo doc1i na sledec1a 4 nachina:
{\eng ah, ax\&0xFF00, eax\&0x0000FF00} ili {\eng rax\&0x000000000000FF00}.


\section{Registri opshte namene}
\medskip

Registri opshte namene imaju ulogu u chuvanju operandi i pokazivacha:
\begin{itemize}
\item Operandi za logichke i aritmetichke operacije
\item Operandi za adresne kalkulacije
\item Pokazivacha na memorijsku lokaciju
\end{itemize}

Registri opshte namene se mogu koristiti proizvoljno prema potrebi. Medjutim,
dizajneri hardvera su uvideli da postoji moguc1nost daljih optimizacija ukoliko
se svakom od ovih registara dodeli neka specifichna uloga u kojoj je malo bolji
od ostalih registara opshte namene.\\

Na taj nachin kompajleri vec1inu vremena kreiraju bolji asemblerski kod nego
ljudi, prosto iz razloga shto svaki od registara opshte namene takodje koriste
i za njihovu specifichnu funkciju svaki put gde je to moguc1e.\\

Specifichna uloga registara opshte namene:
\begin{itemize}
\item {\eng eax} - akumulator za operande i podatke rezultata
\item {\eng ebx} - pokazivach na podatke u {\eng ds} segmentu
\item {\eng ecx} - brojach za petlje i operacije nad stringovima
\item {\eng edx} - pokazivach na U/I
\item {\eng esi} - pokazivach na podatke na koji pokazuje {\eng ds} registar;
    pochetni pokazivach za operacije nad stringovima
\item {\eng edi} - pokazivach na podatke u segmentu na koji pokazuje {\eng es}
    registar; krajnji pokazivach za operacije nad stringovima
\item {\eng esp} - pokazivach na pochetak steka
\item {\eng ebp} - pokazivach na podatke u steku

\end{itemize}

\section{Segmentni registri}
\medskip

Segmentni registri sadrzhe shesnaestobitne selektore segmenta. Selektor segmenta je
specijalan pokazivach koji identifikuje segment u memoriji. Da bi pristupili
odredjenom segmentu u memoriji, selektor segmenta koji pokazuje na taj segment
mora biti dostupan u odgovarajuc1em segmentnom registru.

Specifichna uloga segmentnih registara:
\begin{itemize}
\item {\eng cs - code segment}. {\eng cs} registar sadrzhi selektor segmenta
    koji pokazuje na segment koda u kome se nalaze instrukcije koje se
    izvrshavaju.
\item {\eng ds - data segment}. Osim {\eng ds}, segmentni registri za segmente
    podataka su i {\eng es, fs}, kao i {\eng gs}.
\item {\eng ss - stack segment}. {\eng ss} registar sadrzhi selektor segmenta
    koji pokazuje na segment steka gde se chuva stek programa koji se trenutno
    izvrshava. Za razliku od registra za segment koda, {\eng ss} registar
    se mozhe eksplicitno postaviti shto dozvoljava aplikacijama da postave
    vishe stekova i da alterniraju izmedju njih.
\end{itemize}


\section{{\eng Real mode}}
\medskip

Realni mod karakterishe 20-tobitna segmentirana memorija shto znachi da se
mozhe adresirati samo malo vishe od jednog megabajta. Svi procesori pochev od
80286 zapochinju u ovom modu nakon paljenja rachunara zbog kompatibilnosti. Da
bismo mogli da adresiramo vishe memorije, potrebno je da koristimo segmentne
registre.\\

Postupak kojim iz realnog moda prelazimo u zashtic1eni mod naziva se daleki
skok {\eng (far jump)} gde pri postavljanju segmentnih registara "skachemo" iz
jednog segmenta u drugi. Daleki skok najchesh\/c1e podrazumeva promenu
selektora segmenta, koji se nalazi u segmentu koda, i koji pokazuje na segment
koda u kome se nalaze instrukcije koje se trenutno izvrshavaju.

\section{Segmentacija}
\medskip

Segmentacija je reshenje kojim se omoguc1ava adresiranje vishe memorije nego
shto je to hardverski predvidjeno. Segmentacija se postizhe korish\/c1enjem
{\eng offset}-a. Upravo smo uz pomoc1 segmenatcije u realnom modu adresirali
memoriju sa 20, umesto predvidjenih 16 bitova.

\section{{\eng Protected mode}}
\medskip

Zashtic1eni mod je stanje procesora u kojem procesor ima pun pristup celom
opsegu memorije za razliku od realnog moda. Maksimalna velichina {\eng RAM}
memorije koju arhitektura {\eng i386} podrzhava je {\eng 4GB} upravo zbog
velichine registra od 32 bita ($2^{32}B = 4GB$). Neki procesori koji
podrzhavaju {\eng PAE - Physical Address Extension} podrzhavaju i adresiranje
memorija preko 64 bita. Kasnije je na ovom starndardu utemeljeno i adresiranje
memorija na {\eng X86\_64}.\\

Adresiranje svih 32 bita memorije postizhe se  korish\/c1enjem stranichenja
({\eng paging}), koje nam dozvoljava da mapiramo fizichku memoriju na
virtuelnu. Na taj nachin prilikom izvrshavanja svakog programa mozhe se
zavarati program tako da misli da njegovo izvrshavanje krec1e od pocheka
memorije. Iz tog razloga znachajno nam je olakshano izvrshavanje programa jer
nam svi programi postaju nezavisni od adrese fizichke memorije gde se oni
zapravo nalaze, dok prilikom kreiranja programa mozhemo fiksno postaviti adresu
prve instrukcije.

%{\eng\url{https://wiki.osdev.org/Protected_Mode}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{{\eng Boot}}

\section{Redosled pokretanja}
\medskip

Od pritiska dugmeta za paljenje rachunara, pa do uchitavanja operativnog
sistema postoji ceo jedan proces. Nakon pritiska dugmeta, rachunar prvo
izvrshava {\eng POST (Power On Self Test)} rutinu, koja je jedna od pochetnih
faza {\eng BIOS}-a {\eng (Basic Input Output System)}. U {\eng POST}-u,
rachunar pokushava da inicijalizuje komponente rachunarskog sistema jednu po
jednu, i proverava da li one ispunjavaju sve uslove za startovanje rachunara.
Ukoliko je ceo proces proshao bez greshaka, nastavlja se dalje izvrshavanje
{\eng BIOS}-a. {\eng BIOS} sada ima ulogu da pronadje medijum koji sadrzhi
program koji c1e uchitati jezgro operativnog sistema u ram memoriju rachunara.
Taj program se naziva {\eng Bootloader}.

%{\eng\url{https://wiki.osdev.org/Boot_Sequence}}

\section{{\eng Bootloader}}
\medskip

{\eng Bootloader} je program koji se nalazi u prvih 512 bajtova medijuma u
{\eng MBR} odeljku, i njegov zadatak je da uchita jezgro operativnog sistema u
{\eng RAM} memoriju i preda mu dalje upravljanje. Zbog kompleksnosti danashnjeg
softvera, 512 bajtova je vrlo malo za uchitavanje celog {\eng bootloader}-a. Iz
tog razloga neki {\eng bootloader}-i razdvojeni su u vishe delova,
najchesh\/c1e 2. Prvi deo je vrlo mali, staje u 512 bajtova {\eng MBR}-a i on
sluzhi samo da bi uchitao drugi deo u kome se nalazi glavni kod koji dalje
predaje upravljanje jezgru operativnog sistema.\\

Neki od najpopularnijih {\eng bootloader}-a jesu: {\eng GRUB, LILO,
systemd-boot, rEFInd}, kao i {\eng Windows Boot Manager}. Za potrebe ovog
operativnog sistema korish\/c1en je {\eng GRUB} o kome c1e biti vishe rechi u
odeljku Korish\/c1eni alati.

%{\eng\url{https://wiki.osdev.org/Bootloader}}

\section{{\eng Multiboot} specifikacija}
\medskip

{\eng Multiboot} specifikacija je otvoreni standard koji jezgrima obezbedjuje
ujednachen nachin pokretanja od strane {\eng bootloader}-a usaglashenih sa ovom
specifikacijom. Jedna od prvih stvari koji svako jezgro uradi je postavljanje
konstanti definisanih {\eng multiboot} standardom da bi bilo prepoznato od
strane {\eng bootloader}-a i da bi mu bilo predato dalje upravljanje.

\section{{\eng ELF}}
\medskip

{\eng ELF} je format za skladishtenje programa ili fragmenata programa na
disku, kreiran kao rezultat kompajlovanja i linkovanja. {\eng ELF} fajl je
podeljen na odeljke. Za program koji mozhe da se izvrshi, postoje sledec1i
odeljci: odeljak sa tekstom za kod, odeljak sa podacima za globalne promenljive
i odeljak {\eng ".rodata" (read only data)} koji obichno sadrzhi konstantne
niske. {\eng ELF} fajl sadrzhi zaglavlja koja opisuju kako ovi odeljci treba
da budu uskladishteni u memoriji.\\

Ovaj format definisan je u {\eng System V ABI} ({\eng System V Application
Binary Interface})\cite{misc:3}, koji je set specifikacija koji definishe
pozivanje funkcija, format objektnih fajlova, format fajlova koji mogu da se
izvrshe, dinamichno linkovanje kao i mnoge druge.\\

Funkcije arhitekture {\eng i386}, po konvenciji, povratne vrednosti celobrojnog
tipa chuvaju u {\eng eax} registru, dok se vrednosti koje ne staju u 32
bita {\eng eax} registra "prelivaju" u {\eng edx} registar. Ova informacija c1e
nam biti kljuchna kada budemo pozivali funkcija napisane u {\eng C}-u iz {\eng
Assembler}-a.

%{\eng\url{https://wiki.osdev.org/ELF}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Korish\/c1eni alati}
\bigskip

U daljem tekstu se mogu videti neki od alata korish\/c1enih pri kreiranju ovog
rada. Vec1ina korish\/c1enih alata poseduje {\eng GPLv3} licencu.
{\eng GNU Public Licence} je licenca otvorenog koda koja dozvoljava
modifikovanje i distribuiranje koda sve dok je taj kod javno dostupan.
Jedini programi sa ove liste koji nije kreirao {\eng GNU} su: {\eng QEMU}
virtuelna mashina, {\eng git} i {\eng NeoVim} koji koriste {\eng GPLv2}
licencu.\\

Operativni sistem korish\/c1en u izradi ovog projekta je {\eng Artix Linux}.
{\eng Artix Linux} je {\eng GNU/Linux} distribucija bazirana na {\eng Arch
Linux}-u.
Vec1ina korish\/c1enih programa je vec1 kompajlovana i spremna za upotrebu i
nalazi se u oficijalnim repozitorijima.\\

Za programe koji su morali biti manuelno kompajlovani date su instrukcije u
njihovoj podsekciji. {\eng Binutils} i {\eng GCC} su morali biti naknadno
kompajlovani i to da ne bi koristili standardnu biblioteku koju
nam je obezbedio operativni sistem domac1in (onaj na kome se kompajluje ovaj
projekat), vec1 posebnu bibloteku kreiranu za ovo jezgro. Za ostale programe
koji su korish\/c1eni preporuka je koristiti one koji su dostupni kao spremni
paketi u izvorima odabrane distrubucije {\eng GNU/Linux}-a.

\section{{\eng Binutils}}
\medskip

Izvorni kod softvera se mozhe nac1i na stranici
{\eng\url{https://www.gnu.org/software/binutils/}},
zajedno sa uput\/stvom za kompajlovanje i korish\/c1enje.\\

Ovaj softverski paket sadrzhi programe neophodne za izradu programa od kojih su
najkorish\/c1eniji asembler ({\eng as}), linker ({\eng ld}), kao i program za
kreiranje biblioteka ({\eng ar}).

\subsection{Pre dodavanja {\eng C} biblioteke}
\smallskip

Iz razloga shto se ne koristi standardna biblioteka vec1 samostalno napisana
specifichno za ovaj projekat, potrebno je manuelno kompajlovati {\eng GNU
Binutils}. Medjutim, postoji moguc1nost korish\/c1enja vec1 spremnog paketa
koji se za distribucije bazirane na {\eng Arch Linux}-u mozhe nac1i na stanici
{\eng\url{https://aur.archlinux.org/packages/i686-elf-binutils/}}. Pojedine
distribucije vec1 imaju ovaj paket kompajlovan, ali je preporuka manuelno
kompajlovati da bi se izbegla nekompatibilnost, a i prosto iz razloga shto c1e
nakon formiranja nashe {\eng C} biblioteke biti neophodno kompajlovati ovaj
program za svaki sistem posebno.\\

Za one koje zhele sami da kompajluju {\eng binutils}, dat je deo instrukcija
koji se razlikuje od uput\/stva datog na zvanichnom sajtu a tiche se
konfigurisanja pre kompilacije.\\

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=make]{include/00.alati/binutils/binutils1}\srb\end{minipage}\smallskip

\subsection{Nakon dodavanja  {\eng C} biblioteke}
\smallskip

Nakon dodavanja nashe {\eng C} biblioteke potrebno je kompajlovati {\eng GNU
Binutils} tako da tu biblioteku i koristi prilikom kompajlovanja nasheg
operativnog sistema.

\textbf{Napomena:} Potrebno je postaviti {\eng \$SYSROOT} na lokaciju koja
sadrzhi biblioteku. To je moguc1e uraditi na sledec1i nachin:\\

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=make]{include/00.alati/binutils/exportsysroot}\srb\end{minipage}\smallskip

Instrukcije za kompajlovanje date su u nastavku.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=make]{include/00.alati/binutils/binutils2}\srb\end{minipage}\smallskip

\subsection{{\eng GNU Assembler}}
\smallskip

Iako trenutno postoje mnogo popularnije alternative poput {\eng NASM (Netwide
Assembler)} i {\eng MASM (Microsoft Assembler)} koji koriste noviju Intelovu
sintaksu, autor se ipak odluchio za {\eng GASM} zbog kompatibilnosti sa {\eng
GCC} kompajlerom. {\eng GASM} koristi stariju {\eng AT\&T} sintaksu koju
karakterishe: obrnut poredak parametara, prefiks pre imena registara i
vrednosti konstanti, a i velichina parametara mora biti eksplicitno definisana.
Zbog toga c1e mozhda nekim chitaocima biti koristan program {\eng intel2gas}
koji se za {\eng Arch Linux} mozhe nac1i na stanici
{\eng\url{https://aur.archlinux.org/packages/intel2gas/}}, a koji prevodi
rasprostranjeniju Intelovu sintaksu u {\eng AT\&T} sintaksu.\\

{\eng GNU Assembler} je korish\/c1en za kompajlovanje dela koda
napisanog u asembleru.

\subsection{{\eng GNU Linker}}
\smallskip

{\eng GNU Linker} je korish\/c1en za linkovanje, tj. "spajanje" svog
kompajlovanog koda u jednu binarnu datoteku tipa {\eng ELF} koja predstavlja
jezgro (kernel). Linker koristi {\eng src/linker.ld} skriptu koja definishe na
koji nachin se pakuju sekcije objektnih fajlova, od koje memorijske lokacije
pochinje uchitavanje jezgra, kao i koja je pochetna funkcija od koje krec1e
izvrshavanje. Ova skripta u stvari predstavlja recept za kreiranje navedene
{\eng ELF} datoteke koja u nashem sluchaju chini operativni sistem.

\section{{\eng GCC}}
\medskip

Izvorni kod softvera se mozhe nac1i na stranici
{\eng\url{https://gcc.gnu.org/}}, zajedno sa uput\/stvom za kompajlovanje i
korish\/c1enje.\\

Isto kao i za {\eng GNU Binutils}, moguc1e je pronac1i vec1 spreman paket u
pojedinim distribucijama, ali je preporuka manuelno kompajlovati iz
prethodno navedenih razloga. Za {\eng Arch Linux} ovaj paket se mozhe nac1i na
stanici {\eng\url{https://aur.archlinux.org/packages/i686-elf-gcc/}}.\\

{\eng GCC} je {\eng GNU}-ov set kompajlera koji je korish\/c1en za kompajlovanje
ovog operativnog sistema.

\subsection{Pre dodavanja {\eng C} biblioteke}
\smallskip

Za one koje zhele sami da kompajluju {\eng GCC}, dat je deo instrukcija koji se
razlikuje od uput\/stva datog na zvanichnom sajtu a tiche se konfigurisanja pre
kompilacije.\\

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=make]{include/00.alati/gcc/gcc1}\srb\end{minipage}\smallskip

\subsection{Nakon dodavanja {\eng C} biblioteke}
\smallskip

Instrukcije za kompajlovanje nakon dodavanja biblioteke date su u nastavku.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=make]{include/00.alati/gcc/gcc2}\srb\end{minipage}\smallskip

Kompajlovanje {\eng GCC}-a sa datim opcijama obezbedjuje nam korish\/c1enje
date biblioteke umesto standardne koju nam je obezbedio operativni sistem
domac1in.

\section{{\eng GRUB}}
\medskip

Izvorni kod softvera se mozhe nac1i na stranici
{\eng\url{https://www.gnu.org/software/grub/}}, zajedno sa uput\/stvom za
kompajlovanje i korish\/c1enje.\\

{\eng GRUB (GRand Unified Bootloader)} je {\eng bootloader} koji je
korish\/c1en na ovom projektu. Trenutno korishc1ena verzija ovog softvera je
{\eng GRUB 2}.

Konfiguracioni fajl {\eng grub.cfg} definishe odakle ovaj {\eng bootloader} 
uchitava jezgro i koliki je vremenski okvir izmedju izbora jezgara odnosno
operativnih sistema.

\section{{\eng QEMU}}
\medskip

Vishe informacija o softveru se mozhe nac1i na stranici
{\eng\url{https://www.qemu.org/}}, zajedno sa uput\/stvom za korish\/c1enje.\\

{\eng QEMU} je virtuelna mashina u kojoj c1e jezgro biti testirano i
prikazano zarad praktichnih razloga. {\eng QEMU} je odabran za ovaj projekat
jer za razliku od drugih virtuelnih mashina poseduje {\eng cli (command line
interface)} iz koga se lako mozhe pozivati pomoc1u skripti kao shto su {\eng
Makefile}-ovi.

\section{{\eng Make}}
\medskip

Izvorni kod softvera se mozhe nac1i na stranici
{\eng\url{https://www.gnu.org/software/make/}},
zajedno sa uput\/stvom za kompajlovanje i korish\/c1enje.\\

{\eng Make}\cite{book:78575} nam omoguc1ava da sa lakoc1om odrzhavamo i
manipulishemo izvornim fajlovima. Moguc1e je sve kompajlovati, obrisati,
kreirati {\eng iso} fajl kao i pokrenuti {\eng QEMU} virtuelnu mashinu sa samo
jednom kljuchnom rechi u terminalu. Kreirani {\eng Makefile} za potrebe ovog
projekta bic1e detaljno objashnjen u sekciji {\eng Build system}.

\section{Manje bitni alati}
\medskip

\subsection{{\eng NeoVim}}
{\eng NeoVim} je uredjivach teksta nastao od {\eng Vim}-a ({\eng Vi improved})
\cite{book:78583}. Konfiguracijski fajlovi autora, mogu se nac1i na
{\eng\url{https://github.com/aleksav013/nvim}}, i imaju za cilj da stvore
okruzhenje pogodno za rad na ovom projektu.

\subsection{{\eng git}}
\smallskip

Kreator ovog programa je {\eng Linus Torvalds}, chovek koji je kreirao {\eng
Linux} kernel. Izvorni kod softvera se mozhe nac1i na stranici
{\eng\url{https://git.kernel.org/pub/scm/git/git.git}}.\\

{\eng Git} je program koji nam pomazhe da odrzhavamo izvodne fajlove
sinhronizovanim sa repozitorijumom. Osim toga znachajan je i njegov sistem
kontrole verzija - moguc1nost da se za svaku promenu ({\eng commit}) vidi
tachno koji su se fajlovi izmenili i koja je razlika izmedju neke dve verzije
projekta.

\subsection{{\eng xorriso (libisoburn)}}
\smallskip

Izvorni kod softvera se mozhe nac1i na stranici
{\eng\url{https://www.gnu.org/software/xorriso/}},
zajedno sa uput\/stvom za kompajlovanje i korish\/c1enje.\\

Sluzhi za kreiranje {\eng ISO} fajlova koji se mogu "narezati" na {\eng CD}
disk ili {\eng USB} flesh i koji se kasnije mogu koristiti kao optichki disk
koji sadrzhi sve shto je neophodno za uspeshno podizanje sistema.

\subsection{{\eng GDB}}
\smallskip

Izvorni kod softvera se mozhe nac1i na stranici
{\eng\url{https://www.sourceware.org/gdb/}},
zajedno sa uput\/stvom za kompajlovanje i korish\/c1enje.\\

{\eng GDB} je {\eng GNU}-ov {\eng debugger} koji sluzhi za pronalazhenje
greshaka u kodu, kao i aktivno prac1enje izvrshavanja programa (u ovom sluchaju
jezgra). Uz pomoc1 ovog programa ustanovljeno je shta svako dugme na tastaturi
vrac1a nakon pritiska, shto je znachajno ubzalo proces mapiranja tastature.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Inspiracija}
\bigskip

\section{{\eng Minix}}
\medskip

{\eng Minix} je operativni sistem baziran na {\eng UNIX}-u koji koristi
mikrokernelsku arhitekturu. Pochev od verzije 2.0 zadovoljava {\eng POSIX
(Portable Operating System Interface)} standard. Pochetne verzije {\eng Minix}
operativnog sistema kreirao je Endrju S. Tanenbaum kao profesor Vrije
univerziteta u Amsterdamu. Profesor Tanenbaum kreirao je operativni sistem kao
primer principa koji su prikazani u njegovoj knjizi "Operativni sistemi: Dizajn
i Implementacija" ({\eng Operating Systems: Design and
Implementation})\cite{book:1400099}. Osim ove knjige, Tanenbaum napisao je i
mnoge druge koje mogu biti od koristi svima koji zhele da se bave dizajnom
operativnih sistema\cite{book:821745}\cite{book:915673}.
Zanimljiva chinjenica je da je {\eng Minix} najpopularniji operativni sistem
chije jezgro koristi mikrokernelsku arhitekturu.\\

Spekulishe se da svi Intelovi procesori nakon {\eng Core2Duo} serije koji imaju
chip pod nazivom {\eng Intem ME (Intel Managment Engine)}, zapravo pokrec1u
{\eng Minix} operativni sistem. Ovo bi {\eng Minix} uchinilo
najkorish\/c1enijim operativnim sistemom ikada.


\section{{\eng Linux}}
\medskip

Vec1 duzhe od dve godine koristim operativni sistem sa {\eng Linux} jezgrom
shto je bio i glavni razlog zashto sam izabrao rad na ovu temu.
U toku izrade ovog projekta, pozheleo sam da bolje razumem kako funkcionishe
izrada {\eng Linux} kernela i kako je to "zajednica" ona koja ga pokrec1e i
odrzhava, a ne neka velika korporacija. Stoga sam odluchio da dam svoj doprinos 
i poslao sam nekoliko zakrpa ({\eng patch}-eva) koji su primljeni i
implemetirani u novoj 5.17 verziji {\eng Linux} kernela. Ovo iskustvo pokazalo
mi je koliko je ozbiljna organizacija koja stoji iza celog tog projekta i
koliko je bitno raditi na svim sferama nekog projekta kao shto su i izrada
dokumentacije i spremnost da se edukuju i zainteresuju mladi ljudi kojima c1e
ovakvo iskustvo znachiti u daljem profesionalnom usavrshavanju. Drago mi je
shto me je ovaj projekat odvazhio da nachinim taj korak i doprinesem mozhda
najvec1em softverskom projektu ikada.

\section{{\eng BSD}}
\medskip
Najpopularniji {\eng BSD} operativni sistemi su redom {\eng
FreeBSD\cite{book:1310096}, OpenBSD} i {\eng NetBSD}. Svaki od njih ima
razlichite ciljeve, ali se svi slazhu u jednom: softver mora ostati minimalan.
Svi ovi operativni sistemi svoje sistemske programe i biblioteke imaju napisano
u duplo, ako ne i nekoliko puta manje linija koda nego {\eng GNU/Linux}. To ih
chini mnogo lakshim za odrzhavanje, ali i mnogo sigurnijim.\\

{\eng BSD} operativni sistemi razlikuju se od {\eng GNU/Linux}-a po tome shto
su kod {\eng BSD}-a jezgro i korisnichki programi celina koja je nastala od
strane jednog tima ljudi i odrzhavaju se uporedo, dok je kod {\eng GNU/Linux}-a
jezgro {\eng Linux}, a {\eng GNU Coreutils} chini korisnichke programe {\eng
(user space)} i njihov razvoj je potpuno nezavisan. Zbog te chinjenice, {\eng
BSD} je mnogo lakshe odrzhavati i mnogo brzhe se mogu implementirati nove ideje
i moguc1nosti, prosto iz razloga shto ne zavisi od druge strane da se pre svega
uskladi, a potom i implementira datu promenu. \\

Takodje osim gore navedenih razlika, josh jedna veoma bitna razlika je to shto
{\eng BSD} koristi {\eng MIT} licencu dok {\eng GNU/Linux} koristi {\eng
GPLv2/GPLv3} licencu. To znachi da za {\eng BSD} sisteme nakon modifikacije ne
moramo uchiniti kod javno dostupnim. Ta chinjenica chini {\eng BSD}
vrlo primamljivim za velike korporacije koje na taj nachin svoja softverska
reshenja mogu bazirati na vec1 postojec1im. Tako na primer mnoge konzole
pokrec1u upravo izmenjenu verziju {\eng FreeBSD}-a, dok sa druge strane imamo i
kompanije poput {\eng Apple}-a koja takodje koristi {\eng FreeBSD}, ali kao
podlogu za svoje operativne sisteme za rachunare i mobilne telefone.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{{\eng Build system}}
\bigskip

Sistem koji kreira {\eng toolchain} koji se koristi za kompajlovanje,
linkovanje i kreiranje upotrebljivog operativnog sistema u {\eng ISO} formatu.
Osim seta alata mozhe se videti i {\eng Makefile} koji pamti na koji se tachno
nachin koristi taj set alata da bi se izgradilo jezgro.

\section{{\eng aleksa-toolchain}}
\medskip

U sklopu ovog projekta nastao je i {\eng aleksa-toolchain}, kao i {\eng
shell}\cite{book:2751214} skripta koja kreira taj {\eng toolchain} (set alata)
koji se dalje koristi za kompajlovanje jezgra.

U tekstu koji sledi mozhe se videti koje sve funkcije skripta sadrzhi.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=sh,linerange={131-140}]{include/00.build/setup.sh}\srb\end{minipage}\smallskip

Skripta prvo skida izvorni kod {\eng binutils}-a i {\eng GCC}-a, ekstraktuje iz
arhive, a zatim je {\eng patch}-uje (primenjuje skup izmena). Nakon toga
korish\/c1enjem {\eng GCC} kompajlera na {\eng host} sistemu, kompajluje se
poseban {\eng GCC} kompajler koji sluzhi za kompajlovanje izvornog koda
namenjenog jezgru ovog operativnog sistema. Nakon toga on se instalira na
put {\eng /opt/aleksa/usr/bin/}, gde se nalazi novi {\eng \$SYSROOT} koji
koristi {\eng Makefile} za izgradnju jezgra.

\section{{\eng Makefile}}
\medskip

{\eng Makefile} je fajl koji kontrolishe ponashanje {\eng make} komande u
terminalu. Svaki {\eng Makefile} sadrzhi neki set pravila koji definishe proces
koji se pokrec1e ukucavanjem komande {\eng make $<$ime\_pravila$>$}. U tekstu
koji sledi mozhe se videti koji je to set pravila koje su definisani za ovaj
projekat.\\

{\eng Makefile}:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=make,linerange={68-104}]{include/00.build/Makefile}\srb\end{minipage}\smallskip

\newpage

Osim navedenog seta pravila, u {\eng Makefile}-u mozhemo definisati neke
promenljive koje bi nam omoguc1ile krac1i zapis, izbegavanje ponavljanja
konstanti, kao i znachajno lakshe menjanje istih. One funkcionishu na slichan
nachin kao i pretprocesorske direktive u {\eng C}-u. Primetimo da ispred nekih
linija u kojima dodeljujemo vrednosti promenljivima imamo i kljuchnu rech {\eng
export}. To znachi da c1e se vrednost date promenljive, preneti i u rekurzivni
poziv {\eng Makefile}-a.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=make,linerange={0-22}]{include/00.build/Makefile}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=make,linerange={25-40}]{include/00.build/Makefile}\srb\end{minipage}\smallskip

Mozhemo videti da je ovo kompleksnija forma {\eng Makefile}-a jer sadrzhi
proces rekurzivnog pozivanja {\eng \$(MAKE)} komande. To znachi da ovaj
projekat sadrzhi vishe razlichitih {\eng Makefile}-ova za svaki deo projekta,
shto je i standardna procedura pri velikim projektima kao shto je ovaj.
Konkretno kod ovog jezgra postoje josh dva {\eng Makefile}-a, a tichu se koda
napisanog u {\eng C}-u, kao i koda napisanog u {\eng GNU Assembler}-u za {\eng
X86} arhitekturu.\\

{\eng src/as/Makefile}:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=make]{include/00.build/AS_Makefile}\srb\end{minipage}\smallskip

{\eng src/c/Makefile}:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=make]{include/00.build/C_Makefile}\srb\end{minipage}\smallskip

Na taj nachin bi sa lakoc1om projekat mogao biti proshiren na vishe razlichitih
arhitektura procesora, shto je i autorov plan u buduc1nosti. Biblioteke,
interaktivni {\eng shell}, kao i drajver za tastaturu napisan za ovo jezgo se
ne bi menjali, dok bi zbog specifichnosti druge arhitekture bile promenjene
komponente zaduzhene za pochetnu inicijalizaciju i kontolisanje hardvera na
najnizhem nivou.\\

Za svaki projekat moguc1e je automatizovati deo posla kreiranjem {\eng
Makefile}, pa tako na primer i ovaj maturski rad koji je iskucan u {\eng
LaTeX}-u ima svoj {\eng Makefile}:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=make]{Makefile}\srb\end{minipage}\smallskip


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Jezgro operativnog sistema}
\bigskip

Rad je prvobitno bio zamishljen kao postupno izlaganje nastajanja ovog
operativnog sistema, ali se kasnije autor odluchio da ipak izlozhi samo
trenutnu verziju rada, s obrzirom na to da bi rad bio nepotrebno duzhi.
Jezgro je, kao shto je vec1 recheno napisano u asembleru i {\eng C} programskom
jeziku\cite{book:441007}\cite{book:690930}.

\section{Pochetak}
\medskip
%{\eng\url{https://wiki.osdev.org/Bare_Bones}}

{\eng as/boot.s}:\\

U prvom delu postavljamo promenljive na vrednosti koje su odredjene {\eng
Multiboot} standardom da bi {\eng bootloader} prepoznao nashe jezgro.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=Assembler]{include/01.pocetak/boot1.s}\srb\end{minipage}\smallskip

Nakon toga postavljamo prvih 512 bajtova na prethodno pomenute vrednosti, ali
tako da za svaku promenljivu ostavljamo 32 bita prostora.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=Assembler]{include/01.pocetak/boot2.s}\srb\end{minipage}\smallskip

Postavljamo promenljive koje chuvaju adrese na kojima pochinju segmenti koda i
podataka, redom.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=Assembler]{include/01.pocetak/boot3.s}\srb\end{minipage}\smallskip

Definishemo sekciju {\eng .bss} u kojoj kreiramo stek i dodeljujemo mu 16
kilobajta.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=Assembler]{include/01.pocetak/boot4.s}\srb\end{minipage}\smallskip

Definishemo pochetnu funkciju {\eng \_start} pozivajuc1i funkciju za
inicijalizaciju {\eng gdt} tabele i "skachemo" na segment koda. Ovaj postupak
ima naziv {\eng "far jump"} jer skachemo van tekuc1eg segmenta.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=Assembler]{include/01.pocetak/boot5.s}\srb\end{minipage}\smallskip

U segmentu koda postavljamo segmentne registre na adresu segmenta podataka.
Zatim postavljamo {\eng esp} registar na pochetak steka koji smo
inicijalizovali u {\eng .bss} sekciji i predajemo upravljanje {\eng
kernel\_main} funkciji.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=Assembler]{include/01.pocetak/boot6.s}\srb\end{minipage}\smallskip

Postavljamo velichinu funkcije {\eng \_start} shto nam kasnije mozhe biti
korisno pri {\eng debug}-ovanju.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=Assembler]{include/01.pocetak/boot7.s}\srb\end{minipage}\smallskip


\section{Ispis na ekran - {\eng VGA}}
\medskip

{\eng c/vga.c}:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga1.c}\srb\end{minipage}\smallskip

Primetimo da u {\eng C}-u koristimo {\eng uintX\_t} promenljive. To je zbog
toga shto nam je u ovakvom okruzhenju vrlo bitno da pazimo na velichinu koju
zauzimaju promenljive.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga2.c}\srb\end{minipage}\smallskip

4 znachajnija bita oznachavaju boju pozadine, dok ostala 4 bita oznachavaju
boju karaktera.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga3.c}\srb\end{minipage}\smallskip

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga4.c}\srb\end{minipage}\smallskip

Na {\eng VGA} izlaz ispisujemo karaktere tako shto pochev od adrese {\eng
0xB80000} pishemo shesnaestobitne vrednosti koje se prevode u karaktere i
njihovu boju. 8 znachajnijih bitova odredjuju boju karaktera dok preostalih 8
bitova oznachavaju karakter.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga5.c}\srb\end{minipage}\smallskip

Funkcija koja ispisuje odredjeni karakter na ekranu.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga6.c}\srb\end{minipage}\smallskip

Funkcija koja pomera sve do sada ispisano za jedan red na gore i oslobadja novi
red za ispis kada ponestane mesta na ekranu.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga7.c}\srb\end{minipage}\smallskip

Funkcija koja postavlja brojache kolone i reda na sledec1e, uglavnom prazno,
polje na ekranu.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga8.c}\srb\end{minipage}\smallskip

Funkcija koja postavlja brojache kolone i reda na prethodno polje na ekranu i
koristi se prilikom brisanja prethodno ispisanih karaktera.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga9.c}\srb\end{minipage}\smallskip

Funkcija koja ispisuje jedan karakter na ekranu. Funkcija proverava da li je
potrebno ispisati novi red umesto karaktera {\eng '$\backslash$n'}, kao i da li
je potrebno osloboditi novi red ukoliko se ekran popunio.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga10.c}\srb\end{minipage}\smallskip

Funkcija koja ispisuje niz karaktera na ekran.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga11.c}\srb\end{minipage}\smallskip

Funkcija koja ispisuje celobrojnu vrednost na ekran tako shto je prvo pretvori u
niz karaktera a zatim iskoristi prethodnu funkciju.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga12.c}\srb\end{minipage}\smallskip

Funkcija koja ispisuje realan broj na ekran tako shto je prvo pretvori u niz
karaktera a zatim iskoristi funkciju za ispis niza karaktera.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga13.c}\srb\end{minipage}\smallskip

Funkcija koja brishe sve do sada ispisane karaktere sa ekrana i postavlja
brojache kolone i reda na pochetnu poziciju.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/02.vga/vga14.c}\srb\end{minipage}\smallskip


\section{{\eng Global Desctiptor Table}}
\medskip

Globalna tabela deskriptora je struktura u kojoj se chuvaju informacije o
segmentima memorije.\\

{\eng include/source/gdt.h}:\\

Koristimo {\eng \#ifndef} i {\eng \#define} direktive da bi se osigurali da se
ovaj fajl ukljuchuje ({\eng include}-uje) samo jednom u toku celog rada
operativnog sistema. Ove direktive deluju kao osigurach koji preskache sve
deklaracije ukoliko su one vec1 definisane pod tim imenom.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt1.h}\srb\end{minipage}\smallskip

Autor je kreirao biblioteku {\eng types.h} da bi od\/jednom dodao sve
kompajlerske biblioteke koje definishu vrste promenljivih kao shto su
{\eng int, uint16\_t, bool,...}, kao i konstante kao shto su {\eng true, false,
UINT16\_MAX...}. Na taj nachin u jednom redu se dodaju sve biblioteke zaduzhene
za to, dok se chitljivost rada povec1ava.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt2.h}\srb\end{minipage}\smallskip

Primetimo {\eng \_\_attribute\_\_((packed))}, na kraju definicije strukture. To
nam oznachava da se nec1e ostavljati mesta u memoriji izmedju promenljivih
unutar strukture, vec1 c1e se "pakovati" jedna do druge u memoriji.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt3.h}\srb\end{minipage}\smallskip

Format koji rachunar prihvata za tabelu svih definicija segmenata memorije.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt4.h}\srb\end{minipage}\smallskip

Funkcije koje su definisane u {\eng c/gdt.c}, a tichu se inicijalizacije
globalne tabele deskriptora.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt5.h}\srb\end{minipage}\smallskip

Direktiva za zatvaranje koja se nalazi na kraju fajla i kojom se zavrshava
segment koda predvidjen za deklaracije.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt6.h}\srb\end{minipage}\smallskip

{\eng c/gdt.c}:\\

U {\eng source/} folderu se nalaze prototipi za funkcije istoimenog {\eng C}
izvornog fajla.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt1.c}\srb\end{minipage}\smallskip

Funkcija napisana u {\eng Assembler}-u koja uchitava tabelu deskriptora u
\text predvidjeni registar.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt2.c}\srb\end{minipage}\smallskip

Tabela segmenata i pokazivach na nju koji se prosledjuje prethodno pomenutoj 
funkciji.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt3.c}\srb\end{minipage}\smallskip

Funkcija koja na osnovu parametara inicijalizuje jedan globalni segment
memorije.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt4.c}\srb\end{minipage}\smallskip

Glavna funkcija koja postavlja velichinu pokazivacha koji se prosledjuje,

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt5.c}\srb\end{minipage}\smallskip

inicijalizuje sve segmente memorije koji c1e se koristiti,

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt6.c}\srb\end{minipage}\smallskip

kao i poziva funkciju kojoj prosledjuje pokazivach na globalnu tabelu segmenata
memorije.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/03.gdt/gdt7.c}\srb\end{minipage}\smallskip


%{\eng\url{https://wiki.osdev.org/GDT}}

\section{{\eng Interrupt Desctiptor Table}}
\medskip

Globalna tabela prekida je struktura koja nam govori koja funkcija zapravo
reaguje kada procesor dobije zahtev za prekid ({\eng interrupt request}). Tada
procesor pauzira ono shto trenutno radi i predaje upravljanje odredjenoj
funkciji.\\

Funkcija je duzhna da dojavi procesoru da je c1e ona preuzeti ({\eng
handle}-ovati) taj prekid i ukoliko je prekid fatalan (deljenje nulom, {\eng
triple fault},...) funkcija ima zadatak da ukloni novonastali problem i
obezbedi operativnom sistemu oporavak od greshke.\\

{\eng include/source/idt.h}:\\

Direktive koje se dalje ponavljaju u svakom {\eng header} fajlu. Dalje
pozivanje direktiva c1e biti izostavljeno, radi sushtine.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/04.idt/idt1.h}\srb\end{minipage}\smallskip

%\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/04.idt/idt2.h}\srb\end{minipage}\smallskip

Konstanta koju dalje koristimo pri definisanju prekida.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/04.idt/idt3.h}\srb\end{minipage}\smallskip

Segmenti u memoriji o kojima je u proshloj sekciji bilo rechi.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/04.idt/idt4.h}\srb\end{minipage}\smallskip

Konstante koje chuvaju vrednosti adresa preko kojih dalje komuniciramo sa {\eng
PIC (Programmable Interrupt Controller)}-om.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/04.idt/idt5.h}\srb\end{minipage}\smallskip

Struktura u kojoj rachunar prihvata globalnu tabelu prekida.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/04.idt/idt6.h}\srb\end{minipage}\smallskip

Pokazivach na tabelu prekida koja se prosledjuje funkciji napisanoj u \text{{\eng
Assembler}-u}, a koja uchitava tabelu prekida u odgovarajuc1i registar.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/04.idt/idt7.h}\srb\end{minipage}\smallskip

Prototipi funkcija koji su korishc1eni u sledec1em poglavlju. 

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/04.idt/idt8.h}\srb\end{minipage}\smallskip

Direktive koje se dalje ponavljaju u svakom {\eng header} fajlu. Dalje
pozivanje direktiva c1e biti izostavljeno, radi sushtine.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/04.idt/idt9.h}\srb\end{minipage}\smallskip

%{\eng\url{https://wiki.osdev.org/IDT}}

\section{{\eng IRQ} i {\eng PIC}}
\medskip
{\eng c/idt.c}:\\

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/05.irq/idt1.c}\srb\end{minipage}\smallskip

Asemblerska funkcija koja uchitava pokazivach na tabelu prekida u
predvidjeni registar.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/05.irq/idt2.c}\srb\end{minipage}\smallskip

Tabela prekida i pokazivach na nju koji se prosledjuje prethodno pomenutoj
funkciji.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/05.irq/idt3.c}\srb\end{minipage}\smallskip

Funkcija koja na osnovu pruzhenih parametara definishe prekid u tabeli.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/05.irq/idt4.c}\srb\end{minipage}\smallskip

Funkcija koja dodaje prekid na tabeli u niz koji sadrzhi sve prekide.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/05.irq/idt5.c}\srb\end{minipage}\smallskip

Funkcija koja inicijalizuje kontroler prekida. To je jedan od najbitnijih
chipova koji definishe {\eng X86} arhitekturu. Bez njega ova arhitektura ne bi
bila vodjena principima prekida.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/05.irq/idt6.c}\srb\end{minipage}\smallskip

Funkcija koja definishe sve prekide koje c1emo koristiti uz pomoc1 prethodno
pomenutih funkcija.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C,linerange={1-6,34-37}]{include/05.irq/idt7.c}\srb\end{minipage}\smallskip

Ova funkcija sve podatke o prekidima, skladishtenim u niz, prosledjuje posebno
formiranoj strukturi pokazivacha na tabelu prekida,

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/05.irq/idt8.c}\srb\end{minipage}\smallskip

koji se zatim prosledjuje asemblerskoj funkciji koja uchitava tu tabelu
prekida.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/05.irq/idt9.c}\srb\end{minipage}\smallskip


%{\eng\url{https://wiki.osdev.org/IRQ}}
%{\eng\url{https://wiki.osdev.org/PIC}}

\section{Tastatura}
\medskip

{\eng c/keyboard.c}:\\

Korish\/c1ene biblioteke:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard1.c}\srb\end{minipage}\smallskip

Bafer koji chuva prethodno pozvane funkcije radi implementacije istorije
komanda, kao i brojach bafera na trenutnu komandu.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard2.c}\srb\end{minipage}\smallskip

Tabela koja prevodi kodove koje vrac1a prekid u karaktere koje funkcija
ispisuje. Takodje, chuva se i informacija da li je dati karakter trenutno
pritisnut shto nam mozhe posluzhiti prilikom mapiranja pritiska vishe karaktera
odjednom.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard3.c}\srb\end{minipage}\smallskip

Funkcija za inicijalizaciju tastature. Ova funkcija postavlja jezik tastature i
mapira kodove koje vrac1a {\eng handler} {\eng interrupt request}-a, na
karatkere koji se ispisuju na ekranu.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard4.c}\srb\end{minipage}\smallskip

Funkcija koja koristi prethodno definisane funkcije u drajveru za ispis na
ekran, kako bi obrisala poslednji ispisan karakter i vratila se jedno polje
unazad.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard5.c}\srb\end{minipage}\smallskip

Funkcija koja brishe poslednji ispisan karakter pritiskom na {\eng backspace}
pritom pazec1i da ne ispadne van okvira koji je moguc1e obrisati.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard6.c}\srb\end{minipage}\smallskip

Takodje funkcija azhurira bafer koji chuva do sada pozivane komande.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard7.c}\srb\end{minipage}\smallskip

Funkcija koja definishe ponashanje jezgra nakon pritiska {\eng enter} dugmeta
na tastaturi. Primetimo da se izvrshava komanda koja je u tom trenutku u
baferu, a nakon toga se dati bafer chuva u istoriji bafera.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard8.c}\srb\end{minipage}\smallskip

Funkcija koja odredjuje ponashanje jezgra nakon pritiska {\eng space} dugmeta
na tastaturi.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard9.c}\srb\end{minipage}\smallskip

Funkcija koja odredjuje ponashanje jezgra nakon pritiska dugmeta sa strelicom
okrenutom ka gore, na tastaturi.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard10.c}\srb\end{minipage}\smallskip

Funkcija koja odredjuje ponashanje jezgra nakon pritiska dugmeta sa strelicom
okrenutom ka dole, na tastaturi.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard11.c}\srb\end{minipage}\smallskip

Funkcija koja je postavljena u tabeli prekida da odgovori na prekide koji se
tichu tastature.

%\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard12.c}\srb\end{minipage}\smallskip
%\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard13.c}\srb\end{minipage}\smallskip

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard14.c}\srb\end{minipage}\smallskip

Ona uzima kod koji vrac1a prekid i pretvara ga u karakter ili izvrshava neku od
prethodno navedenih funkcija u zavisnosti od toga koji karakter je pritisnut na
tastaturi.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard15.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard16.c}\srb\end{minipage}\smallskip

Ovde se mozhe videti kako se na primer neka kombinacija karaktera mozhe
iskoristiti za definisanje prechica na tastaturi.

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard17.c}\srb\end{minipage}\smallskip



\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/06.keyboard/keyboard18.c}\srb\end{minipage}\smallskip

\section{{\eng PIT - Programmable Interval Timer}}
\medskip

{\eng c/timer.c}:\\



\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/07.pit/timer1.c}\srb\end{minipage}\smallskip



\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/07.pit/timer2.c}\srb\end{minipage}\smallskip



\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/07.pit/timer3.c}\srb\end{minipage}\smallskip



\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/07.pit/timer4.c}\srb\end{minipage}\smallskip



\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/07.pit/timer5.c}\srb\end{minipage}\smallskip



\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/07.pit/timer6.c}\srb\end{minipage}\smallskip



\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/07.pit/timer7.c}\srb\end{minipage}\smallskip

%{\eng\url{https://wiki.osdev.org/PIT}}

\section{{\eng Heap}}
\medskip

{\eng Heap} za ovo jezgro koristi algoritam\cite{book:1412} bitmape da bi na
najefikasniji nachin sachuvalo podatke o trenutno korish\/c1enim blokovima. Hip
nam sluzhi da bismo dinamichki alocirali memoriju, tj. da bismo mogli da
koristimo globalne promenljive, kao i promenljive chiji zhivotni vek mora biti
dugotrajniji od funkcije u kojoj je ta promenljiva nastala.\\

{\eng c/heap.c}:\\


\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap1.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap2.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap3.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap4.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap5.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap6.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap7.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap8.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap9.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap10.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap11.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap12.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap13.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap14.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap15.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap16.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap17.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap18.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap19.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap20.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap21.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap22.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap23.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap24.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap25.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap26.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap27.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap28.c}\srb\end{minipage}
\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/08.heap/heap29.c}\srb\end{minipage}

%{\eng\url{https://wiki.osdev.org/Heap}}

\section{{\eng Paging}}
\medskip

{\eng c/paging.c}:\\

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/09.paging/paging1.c}\srb\end{minipage}\smallskip

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/09.paging/paging2.c}\srb\end{minipage}\smallskip

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/09.paging/paging3.c}\srb\end{minipage}\smallskip

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/09.paging/paging4.c}\srb\end{minipage}\smallskip

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/09.paging/paging5.c}\srb\end{minipage}\smallskip

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/09.paging/paging6.c}\srb\end{minipage}\smallskip

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/09.paging/paging7.c}\srb\end{minipage}\smallskip

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/09.paging/paging8.c}\srb\end{minipage}\smallskip

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/09.paging/paging9.c}\srb\end{minipage}\smallskip

%{\eng\url{https://wiki.osdev.org/Paging}}

\section{Minimalna \eng{C} biblioteka}
\medskip
%{\eng\url{https://wiki.osdev.org/Creating_a_C_Library}}

Zbog vec1 do sada velike opshirnosti rada, ovde c1e biti prikazana samo
minimalna {\eng C} biblioteka potrebna za kompajlovanje jezgra operativnog
sistema. Primetimo da neki od fajlova moraju samo postojati, tj. mogu biti i
prazni.\\

{\eng include/errno.h}:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/10.libc/errno.h}\srb\end{minipage}\smallskip

{\eng include/stdio.h}:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/10.libc/stdio.h}\srb\end{minipage}\smallskip

{\eng include/stdlib.h}:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/10.libc/stdlib.h}\srb\end{minipage}\smallskip

{\eng include/string.h}:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/10.libc/string.h}\srb\end{minipage}\smallskip

{\eng include/time.h}:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/10.libc/time.h}\srb\end{minipage}\smallskip

{\eng include/unistd.h}:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/10.libc/unistd.h}\srb\end{minipage}\smallskip

{\eng include/sys/types.h}:

\medskip\begin{minipage}{\textwidth}\eng\lstinputlisting[language=C]{include/10.libc/sys/types.h}\srb\end{minipage}\smallskip



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Zakljuchak}

Danas, kada postoje mnogobrojni vishi programski jezici, kreiranje operativnog
sistema je vrlo tezhak izazov za koji se vrlo malo ljudi opredeljuje. Medjutim,
za mene, ovo je jedno vrlo ohrabrujuc1e iskustvo sa kojim tek nekolicina mozhe
da se pohvali. Zheleo bih da u buduc1nosti primarno programiram u nizhim
programskim jezicima kao shto su {\eng Assembler} i {\eng C}, prosto iz razloga
shto smatram da je to jedini nachin da se na duzhe staze izvojeva pobeda po
pitanju performansi u odnosu na neke apstraktnije programske jezike. Osec1aj
koji donosi chinjenica da se moj kod izvrshava direktno na hardveru bez bilo
kakvog posrednika je meni od neprocenljivog znachaja.\\

Da bih odvazhio chitaoce, kao i sve druge koje ova tema zanima, da se i sami
oprobaju u izradi operativnog sistema, sve izvorne fajlove ovog projekta
objavio sam pod {\eng GPLv3} licencom, kao i sve svoje dosadashnje projekte, na
stranici {\eng\url{https://github.com/aleksav013}}. Svi moji projekti su {\eng
open source} shto znachi da kod mozhe posluzhiti svakome ko zheli da sazna
neshto vishe.\\

U toku izrade suochio sam se sa mnogobrojnim problemima. Najtezhi deo je bio
ispolovljavanje i zapochinjanje ove ekspedicije. More informacija i standarda
koji su morali biti zadovoljeni samo da bi se sistem pokrenuo, a zatim i
ispisao neku korisnu informaciju, a kamoli neshto vishe. Najtezhe je bilo to
shto nije bilo moguc1e dodati bilo kakvu funkcionalnost bez da se u potpunosti
razume svaka linija koda. Preduslov za svaku, makar i najsitniju izmenu, bio je
iscrpno i do detalja ish\/chitati dokumentaciju za predvidjenu oblast, ako ta
dokumentacija uopshte i postoji.\\

\newpage

Ovaj projekat je bio sjajan pokazatelj koliko je zapravo kompleksna izrada
jezgra operativnog sistema koji treba da predstavlja most izmedju hardvera i
softvera. Drago mi je shto sam odabrao ovako tezhak projekat za maturski rad iz
razloga shto mi je to pomoglo da probijem barijeru i ulozhim puno truda da bih
zapravo razumeo kako rade operativni sistemi i koliko je sofisticiran njihov
dizajn.\\

Izabrao sam ovu temu iz razloga shto istovremeno povezuje {\eng Linux} i
programiranje u {\eng C} programskom jeziku, moje trenutno dve omiljene stvari,
na predlog mog mentora. Iskoristio bih ovu priliku da se zahvalim profesoru
Miloshu Arsic1u, kao i profesoru Filipu Had2ic1u na sjajnim idejama i
usmeravanju prilikom izrade ovog maturskog rada, kao i svim drugarima,
profesorima i porodici koji su me podrzhali.


\thispagestyle{empty}
\mbox{}
\clearpage

\nocite{*}
\printbibliography[heading=bibintoc,title={Literatura}]

\end{document}
